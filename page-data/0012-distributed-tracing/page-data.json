{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/0012-distributed-tracing/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Blog of Sebastian Häni"}},"markdownRemark":{"id":"84394dcc-3489-5339-952d-7bc390ea704d","excerpt":"Distributed Tracing Distributed Tracing enables us to follow invocations across services and monitor them. We can observe a single service using logs and…","html":"<h2 id=\"distributed-tracing\" style=\"position:relative;\"><a href=\"#distributed-tracing\" aria-label=\"distributed tracing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Distributed Tracing</h2>\n<p>Distributed Tracing enables us to follow invocations across services and monitor them. We can observe a single service using logs and metrics. But what if we have a chain of services that fulfill a single purpose for an end user? For example if we have a user that clicks on an order button in a web frontend, we call the frontend’s backend BFF (I personally favour the <strong>B</strong>ackend-<strong>f</strong>or-<strong>F</strong>rontend pattern) which internally calls an inventory microservice to see if the product is available, and also calls a billing microservices get the user’s bill they will need to approve. If the billing service returns an error instead, the BFF returns an error to the user. However the inventory microservice returned a successful response. If we only have logs and metrics, we do not know what we just described, we simply know there were some errors, but their correlation is not given. With tracing we know that an error in a service very likely lead to another error in the consumer service if they are in the same recorded trace.</p>\n<p>A trace has an ID and consists of one or more spans. A span has an ID, timestamp, duration, a local and a remote endpoint as well as a name. For REST calls we traditionally use the HTTP method and path as the span name. Now, how can we collect spans that form a trace from different services running in different containers? The service that starts a trace is generating a trace ID and with every request it creates in the trace context, it not only creates a span, but it also sends the generated trace ID as an HTTP header starting with <code class=\"language-text\">b3-</code>. See <a href=\"https://github.com/openzipkin/b3-propagation\">B3-Propoagation</a> to learn more about B3 headers. The service answering this request picks up the B3 header and does not generate a new trace ID, but instead uses the provided trace ID. If this service calls yet another service, it simply passes on the trace ID it received. This is handled by instrumentation libraries and a developer usually does not have to care about this, except configuring the tracer library. With OpenTracing this API has been abstracted, so different instrumentations can be swapped without changing the code. As OpenTelemetry not only specifies APIs but also provides implementations of these, we can use OpenTelemetry solely as instrumentation library which provides compatibility to OpenTelemetry Collector, Prometheus and Jaeger.</p>\n<p>So, each service now knows to which trace its span belong to, but how do we collect this information? This is where the OpenCensus project comes in. We could tell our services to send the spans to an OpenTelemetry Collector or to a Jaeger collector. Given the common trace ID, the tracing backend can then correlate the spans together and display them in a single timeline. Sending spans in batches to a collector can impact your service’s performance, so there are options to also do this using a sidecar / agent approach, which involves running another process on the same host next to the service container or even a process running in the same container using process daemons TODO.</p>\n<p>TODO trace timeline image</p>\n<p>Tracing data is complementary to logs and metrics and does not replace them.</p>\n<p>Using tracing data, we can also visualize system architectures based on data. Especially with microservices and with chaos engineering, your system architecture diagrams will quickly be outdated. We can analyze the local and remote endpoints of each span and determine the direction of communication between two services. Aggregated over all spans we get a dependency map. If we index this data we can even query for the map during a time frame and even visualize troughputs and error rates on edges between services.</p>\n<p>TODO dependency map</p>\n<h2 id=\"instrumentation\" style=\"position:relative;\"><a href=\"#instrumentation\" aria-label=\"instrumentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Instrumentation</h2>\n<p>TODO</p>\n<h2 id=\"collector\" style=\"position:relative;\"><a href=\"#collector\" aria-label=\"collector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Collector</h2>\n<p>TODO\nexporters, …</p>\n<h2 id=\"tools\" style=\"position:relative;\"><a href=\"#tools\" aria-label=\"tools permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools</h2>\n<p>Jaeger, Zipkin, …</p>\n<h2 id=\"system-architecture\" style=\"position:relative;\"><a href=\"#system-architecture\" aria-label=\"system architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>System Architecture</h2>\n<p>diagram</p>\n<h2 id=\"upcoming\" style=\"position:relative;\"><a href=\"#upcoming\" aria-label=\"upcoming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Upcoming</h2>\n<p>TODO, post about Java Springboot, post about angular, post about react</p>","fields":{"slug":"/0012-distributed-tracing/"},"frontmatter":{"title":"Distributed Tracing","date":"July 30, 2022","description":null,"tags":["DevOps","Tracing","Monitoring"]}}},"pageContext":{"slug":"/0012-distributed-tracing/","previous":{"fields":{"slug":"/0011-opentelemetry-intro/"},"frontmatter":{"title":"OpenTelemetry Introduction","tags":["DevOps","Tracing","Monitoring"]}},"next":null}},
    "staticQueryHashes": ["3274528899","3333504701"]}